let ApolloError,SignUpValidator,hash,compare,createToken;_f8c‍.x([["default",()=>_f8c‍.o]]);_f8c‍.w("apollo-server-express",[["ApolloError",["ApolloError"],function(v){ApolloError=v}]]);_f8c‍.w("../../validators/user",[["SignUpValidator",["SignUpValidator"],function(v){SignUpValidator=v}]]);_f8c‍.w("bcryptjs",[["hash",["hash"],function(v){hash=v}],["compare",["compare"],function(v){compare=v}]]);_f8c‍.w("../../providers/jwt",[["createToken",["createToken"],function(v){createToken=v}]]);




_f8c‍.d({
    Query: {

        Login: async (_, { identifier, password }, { db }) => {

            var result = db.User.findAll();
            _f8c‍.g.console.log(result);

            return "Kachihaja";
        }
    },

    Mutation: {
        SignUp: async (_, { user }, { db }) => {
            try {
                // validate inputs 
                await SignUpValidator.validate(user, { abortEarly: true })
                // check the password confirmation 
                if (user.password != user.confirmPassword)
                    throw Error("Password not match");

                user.password = await hash(user.password, 10);
                // create token 
                var token = await createToken(user.email, user.password);
                // create and return user 
                var user = await db.User.create(user);


                return { 
                    user , 
                    token  
                }
                
            } catch (error) {
                return new ApolloError(error.message);
            }
        }
    }
});